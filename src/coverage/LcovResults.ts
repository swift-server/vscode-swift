//===----------------------------------------------------------------------===//
//
// This source file is part of the VSCode Swift open source project
//
// Copyright (c) 2021-2022 the VSCode Swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of VSCode Swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import * as vscode from "vscode";
import * as lcov from "lcov-parse";
import * as asyncfs from "fs/promises";
import configuration from "../configuration";
import { FolderContext } from "../FolderContext";
import { execFileStreamOutput } from "../utilities/utilities";
import { BuildFlags } from "../toolchain/BuildFlags";
import { TemporaryFolder } from "../utilities/tempFolder";
import { Writable } from "stream";

/**
 * Class keeping a record of the latest test coverage results for a package
 */
export class LcovResults implements vscode.Disposable {
    private lcovFiles: Buffer[] = [];

    constructor(private folderContext: FolderContext) {}

    dispose() {
        this.lcovFiles = [];
    }

    public async computeCoverage(): Promise<lcov.LcovFile[]> {
        const folder = await TemporaryFolder.create();
        const folderContext = this.folderContext;
        async function merge(files: string[]): Promise<lcov.LcovFile[]> {
            return await folder.withTemporaryFile("profdata", async mergedProfileFile => {
                try {
                    // Merge all the profdata files from each test binary.
                    await LcovResults.mergeProfdata(folderContext, files, mergedProfileFile);

                    // Then export to the final lcov file that can be fed
                    const lcovData = await LcovResults.exportProfdata(
                        folderContext,
                        mergedProfileFile
                    );

                    // const buffer = await asyncfs.readFile(lcovFileName, "utf8");
                    return await LcovResults.loadLcov(lcovData.toString("utf8"));
                } catch (error) {
                    return [];
                }
            });
        }

        const filenames: string[] = [];
        const lcovFiles = this.lcovFiles;
        async function createTempFileAndProcess(index: number): Promise<lcov.LcovFile[]> {
            if (index < lcovFiles.length) {
                return await folder.withTemporaryFile("profdata", async filename => {
                    await asyncfs.writeFile(filename, lcovFiles[index]);
                    filenames.push(filename);
                    return await createTempFileAndProcess(index + 1);
                });
            } else {
                return await merge(filenames);
            }
        }

        return await createTempFileAndProcess(0);
    }

    /**
     * Captures profdata generated by a test run with `swift test --enable-code-coverage`.
     * When all test binaries have executed merge the results with `computeCoverage()`
     */
    async generate() {
        const buildDirectory = BuildFlags.buildDirectoryFromWorkspacePath(
            this.folderContext.folder.fsPath,
            true
        );
        const result = await asyncfs.readFile(`${buildDirectory}/debug/codecov/default.profdata`);
        this.lcovFiles.push(result);
    }

    /**
     * Merges multiple `.profdata` files into a single `.profdata` file.
     */
    private static async mergeProfdata(
        folderContext: FolderContext,
        profDataFiles: string[],
        outputFile: string
    ) {
        const toolchain = folderContext.workspaceContext.toolchain;
        const llvmProfdata = toolchain.getToolchainExecutable("llvm-profdata");
        await execFileStreamOutput(
            llvmProfdata,
            ["merge", "-sparse", "-o", outputFile, ...profDataFiles],
            null,
            null,
            null,
            {
                env: process.env,
                maxBuffer: 16 * 1024 * 1024,
            },
            folderContext
        );
    }

    /**
     * Exports a `.profdata` file using `llvm-cov export`, returning the result as a `Buffer`.
     */
    private static async exportProfdata(
        folderContext: FolderContext,
        mergedProfileFile: string
    ): Promise<Buffer> {
        const packageName = folderContext.swiftPackage.name;
        const buildDirectory = BuildFlags.buildDirectoryFromWorkspacePath(
            folderContext.folder.fsPath,
            true
        );
        const llvmCov = folderContext.workspaceContext.toolchain.getToolchainExecutable("llvm-cov");

        let xcTestBinary = `${buildDirectory}/debug/${packageName}PackageTests.xctest`;
        if (process.platform === "darwin") {
            xcTestBinary += `/Contents/MacOS/${packageName}PackageTests`;
        }

        const swiftTestBinary = `${buildDirectory}/debug/${packageName}PackageTests.swift-testing`;

        let buffer = Buffer.alloc(0);
        const writableStream = new Writable({
            write(chunk, encoding, callback) {
                buffer = Buffer.concat([buffer, chunk]);
                callback();
            },
        });

        await execFileStreamOutput(
            llvmCov,
            [
                "export",
                "--format",
                "lcov",
                xcTestBinary,
                swiftTestBinary,
                "--ignore-filename-regex=Tests|swift-testing|Testing|.build|Snippets|Plugins",
                `--instr-profile=${mergedProfileFile}`,
            ],
            writableStream,
            writableStream,
            null,
            {
                env: { ...process.env, ...configuration.swiftEnvironmentVariables },
                maxBuffer: 16 * 1024 * 1024,
            },
            folderContext
        );

        return buffer;
    }

    private static async loadLcov(lcovContents: string): Promise<lcov.LcovFile[]> {
        return new Promise<lcov.LcovFile[]>((resolve, reject) => {
            lcov.source(lcovContents, (error, data) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(data ?? []);
                }
            });
        });
    }
}
